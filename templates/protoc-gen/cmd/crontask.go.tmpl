// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
package cmd

import (
	{{ if not .CronTasks }}"errors"{{ end }}
	"fmt"
	"os"

	"github.com/spf13/cobra"
	log "github.com/sirupsen/logrus"
	{{ if .HasMemoryQueue }}"runtime"{{ end }}
	{{ if .CronTasks }}"{{ .GoPkg }}/cmd/crontask"
	"{{ .GomeetPkg }}/utils/jwt"
	"{{ .GoPkg }}/cmd/functest"{{ end }}

	{{ if .SubServices }}gomeetService "{{ .GomeetPkg }}/utils/service"{{ end }}
)

var (
	taskName string

	// cronTaskCmd represents the functest command
	cronTaskCmd = &cobra.Command{
		Use:   "crontask",
		Short: "Runs tasks triggered by a time-based job scheduler like cron",
		Run: func(cmd *cobra.Command, args []string) {
			runCronTask()
		},
	}
)

func init() {
	rootCmd.AddCommand(cronTaskCmd)

	// task name
	cronTaskCmd.PersistentFlags().StringVarP(&taskName, "task", "t", "", "Name of the task to run [{{ range $i, $e := .CronTasks }}{{ if $i }}|{{ end }}{{ lowerSnakeCase $e }}{{ end }}]")

	// force debug mode
	cronTaskCmd.PersistentFlags().BoolVarP(&debugMode, "debug", "d", false, "Force debug mode")

	// address flag (to serve all protocols on a single port)
	// cronTaskCmd.PersistentFlags().StringVarP(&serverAddress, "address", "a", "localhost:13000", "Multiplexed gRPC/HTTP server address")

	// gRPC address flag (to serve gRPC on a separate address)
	// cronTaskCmd.PersistentFlags().StringVar(&grpcServerAddress, "grpc-address", "", "gRPC server address")

	// HTTP/1.1 address flag (to serve HTTP on a separate address)
	// cronTaskCmd.PersistentFlags().StringVar(&httpServerAddress, "http-address", "", "HTTP server address")

	// cors flag
	// cronTaskCmd.PersistentFlags().StringVarP(&corsAllowedOrigins, "cors", "c", "*", "Cross Origin Resource Sharing AllowedOrigins (string) separed by | ex: http://*gomeet.com|http://*example.com")

	// CA certificate
	cronTaskCmd.PersistentFlags().StringVar(&caCertificate, "ca", "", "X.509 certificate of the Certificate Authority (required for gRPC TLS support)")

	// gRPC client certificate
	cronTaskCmd.PersistentFlags().StringVar(&serverCertificate, "cert", "", "X.509 certificate (required for gRPC TLS support)")

	// gRPC client private key
	cronTaskCmd.PersistentFlags().StringVar(&serverPrivateKey, "key", "", "RSA private key (required for gRPC TLS support)")

	// JWT secret signing key
	cronTaskCmd.PersistentFlags().StringVar(&jwtSecret, "jwt-secret", "", "JSON Web Token secret signing key (embedded server only)")

	// JSON Web Token
	cronTaskCmd.PersistentFlags().StringVar(&jwtToken, "jwt", "", "JSON Web Token (external server only)")

	// maxRecvMsgSize a ServerOption to set the max message size in bytes the server can receive
	cronTaskCmd.PersistentFlags().IntVar(&maxRecvMsgSize, "max-recv-msg-size", 10, "The max message size in mega bytes the server can receive")

	// maxSendMsgSize a ServerOption to set the max message size in bytes the server can receive
	cronTaskCmd.PersistentFlags().IntVar(&maxSendMsgSize, "max-send-msg-size", 10, "The max message size in mega bytes the server can send")

	// request timeout
	cronTaskCmd.PersistentFlags().IntVar(&timeoutSeconds, "timeout", 5, "Request timeout in seconds")

	{{ range .QueueTypes }}// Main queue system
	{{ if eq . "memory" }}
	cronTaskCmd.PersistentFlags().IntVar(&{{ lowerPascalCase . }}QueueWorkerCount, "{{ lower . }}-queue-worker-count", runtime.NumCPU(), "The number of spawned workers (default is num cpu)")
	cronTaskCmd.PersistentFlags().IntVar(&{{ lowerPascalCase . }}QueueMaxSize, "{{ lower . }}-queue-max-size", 100, "The max size of buffered asynchronous job queue (default 100)")
	{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
	{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
	{{ else if eq . "sqs" }}// sqs support is not yet implemented
	{{ end }}{{ end }}

	{{ range .DbTypes }}
	{{ if eq . "mysql" }}// {{ upperPascalCase . }} data source name: https://github.com/go-sql-driver/{{ lower . }}#dsn-data-source-name
	cronTaskCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} connection informations (USERNAME:PASSWORD@tcp(HOSTNAME:PORT)/DBNAME)")
	{{ else if eq . "postgres" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	cronTaskCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} connection informations (host=HOSTNAME port=DBPORT user=USERNAME dbname=DBNAME password=PASSWORD)")
	{{ else if eq . "sqlite" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	cronTaskCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} data source file")
	{{ else if eq . "mssql" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	cronTaskCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} connection informations (sqlserver://USERNAME:PASSWORD@tcp(HOSTNAME:PORT)?database=DBNAME)")
	{{ end }}
	{{ end }}{{ range .ExtraServeFlags }}// {{ lowerPascalCase .Name }} flag is pass to gRPC server
	cronTaskCmd.PersistentFlags().{{ title .Type }}Var(&{{ lowerPascalCase .Name }}ExtraFlag, "{{ lowerKebabCase .Name }}", {{ if eq .Type "string" }}"{{ end }}{{ .DefaultValue }}{{ if eq .Type "string" }}"{{ end }}, "{{ .Description }}")
	{{ end }}

	{{ range .SubServices }}// {{ upperPascalCase .ShortName }} service address
	cronTaskCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase .ShortName }}Address, "svc-{{ lowerKebabCase .ShortName }}-address", gomeetService.INPROCESS_ADDRESS, "{{ upperPascalCase .ShortName }} service address (host:port) if empty, the sub-service is embed with svc-{{ lowerKebabCase .ShortName }}-* flags has parameters")
	{{ $ss := . }}{{ range .QueueTypes }}// {{ upperPascalCase $ss.ShortName }} queue system
	{{ if eq . "memory" }}
	cronTaskCmd.PersistentFlags().IntVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-queue-worker-count", runtime.NumCPU(), "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} number of spawned workers (default is num cpu)")
	cronTaskCmd.PersistentFlags().IntVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-queue-max-size", 100, "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} max size of buffered asynchronous job queue (default 100)")
	{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
	{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
	{{ else if eq . "sqs" }}// sqs support is not yet implemented
	{{ end }}{{ end }}
	{{ range .DbTypes }}
	{{ if eq . "mysql" }}// {{ upperPascalCase . }} data source name: https://github.com/go-sql-driver/{{ lower . }}#dsn-data-source-name
	cronTaskCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} connection informations (USERNAME:PASSWORD@tcp(HOSTNAME:PORT)/DBNAME)")
	{{ else if eq . "postgres" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	cronTaskCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} connection informations (host=HOSTNAME port=DBPORT user=USERNAME dbname=DBNAME password=PASSWORD)")
	{{ else if eq . "sqlite" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	cronTaskCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} data source file")
	{{ else if eq . "mssql" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	cronTaskCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} connection informations (sqlserver://USERNAME:PASSWORD@tcp(HOSTNAME:PORT)?database=DBNAME)")
	{{ end }}{{ end }}{{ range .ExtraServeFlags }}
	cronTaskCmd.PersistentFlags().{{ title .Type }}Var(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lowerKebabCase .Name }}", {{ if eq .Type "string" }}"{{ end }}{{ .DefaultValue }}{{ if eq .Type "string" }}"{{ end }}, "{{ .Description }}")
	{{ end }}{{ end }}
}

func runCronTask() {
	fmt.Println(svcBiAddress)
	os.Exit(1)
	var taskError error

	// define log level
	if debugMode {
		log.SetLevel(log.DebugLevel)
	} else {
		log.SetLevel(log.PanicLevel)
	}

{{ if .CronTasks }}
	// if JWT is enabled, clients require a valid token
	if jwtSecret != "" {
		var err error
		jwtToken, err = jwt.Create(
			"{{ .GomeetPkg }}",
			jwtSecret,
			tokenLifetimeHours,
			subjectID,
			jwt.Claims{},
		)

		if err != nil {
			fmt.Printf("failed to create JWT : %v\n", err)
			os.Exit(1)
		}
	}

	// initialize config
	// FIXME: refactoring config to a config tree struct
	config := functest.FunctionalTestConfig{
		ServerAddress:      serverAddress,
		GrpcServerAddress:  grpcServerAddress,
		HttpServerAddress:  httpServerAddress,
		CaCertificate:      caCertificate,
		ClientCertificate:  serverCertificate,
		ClientPrivateKey:   serverPrivateKey,
		TimeoutSeconds:     timeoutSeconds,
		JsonWebTokenSecret: jwtSecret,
		JsonWebToken:       jwtToken,
		MaxRecvMsgSize:     maxRecvMsgSize,
		MaxSendMsgSize:     maxSendMsgSize,
		TokenLifetimeHours: tokenLifetimeHours,
		SubjectID:          subjectID,
		IsEmbeddedServer:   useEmbeddedServer,
		IsRandomPort:       useRandomPort,

		//extra parameters

		{{ range .DbTypes }}{{ upperPascalCase . }}DataSourceName: {{ lowerPascalCase . }}DataSourceName,
		{{ end }}
		{{ range .QueueTypes }}{{ if eq . "memory" }}{{ upperPascalCase . }}QueueWorkerCount:  {{ lowerPascalCase . }}QueueWorkerCount,
		{{ upperPascalCase . }}QueueMaxSize:  {{ lowerPascalCase . }}QueueMaxSize,
		{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
		{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
		{{ else if eq . "sqs" }}// sqs support is not yet implemented
		{{ end }}{{ end }}
		{{ range .ExtraServeFlags -}}{{ upperPascalCase .Name }}ExtraFlag: {{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}
		{{ if .SubServices -}}{{ range .SubServices }}{{ $ss := . }}Svc{{ upperPascalCase .ShortName }}Address: svc{{ upperPascalCase .ShortName }}Address,
		{{ range .DbTypes }}Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName: svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName,
		{{ end }}
		{{ range .QueueTypes }}{{ if eq . "memory" }}Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount:  svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount,
		Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize:  svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize,
		{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
		{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
		{{ else if eq . "sqs" }}// sqs support is not yet implemented
		{{ end }}{{ end }}
		{{ range .ExtraServeFlags }}Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag: svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag,
		{{ end }}{{ end }}{{ end }}
	}

	if taskName == "" {
		fmt.Printf("A task name must be provided with the -t/--task flag\n")
		os.Exit(1)
	}


	switch taskName {
{{ range .CronTasks }}	case "{{ lowerSnakeCase . }}":
		taskError = crontask.{{ upperPascalCase . }}(config)
{{ end }}
	default:
		taskError = fmt.Errorf("unknown task \"%s\"", taskName)
	}
{{ else }}
	taskError = errors.New("no defined tasks")
{{ end }}

	if taskError != nil {
		fmt.Printf("Error: %v\n", taskError)
		os.Exit(1)
	}

	os.Exit(0)
}
