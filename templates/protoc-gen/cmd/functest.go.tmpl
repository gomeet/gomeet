// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
package cmd

import (
	"fmt"
	"net"
	"os"
  {{ range .DbTypes }}{{ if eq . "mysql" }}"strings"{{ end }}{{ end }}

	{{ if .DbTypes }}"github.com/jinzhu/gorm"
	{{ range .DbTypes }}_ "github.com/jinzhu/gorm/dialects/{{ lower . }}"
	{{ end }}{{ end -}}
	"github.com/spf13/cobra"
	log "github.com/sirupsen/logrus"

	"{{ .GomeetPkg }}/utils/jwt"

	"{{ .GoPkg }}/cmd/functest"
	{{ if .DbTypes }}"{{ .GoPkg }}/models"{{ end }}
)

var (
	useEmbeddedServer bool
	useRandomPort     bool
	{{ range .DbTypes }}{{ lowerPascalCase . }}FunctestMigrate        bool
	{{ end }}

	// funcTestCmd represents the functest command
	funcTestCmd = &cobra.Command{
		Use:   "functest",
		Short: "Runs functional tests on the service",
		Run: func(cmd *cobra.Command, args []string) {
			runFunctionalTests()
		},
	}
)

func init() {
	rootCmd.AddCommand(funcTestCmd)

	// force debug mode
	funcTestCmd.PersistentFlags().BoolVarP(&debugMode, "debug", "d", false, "Force debug mode")

	// address flag (to serve all protocols on a single port)
	funcTestCmd.PersistentFlags().StringVarP(&serverAddress, "address", "a", "localhost:13000", "Multiplexed gRPC/HTTP server address")

	// gRPC address flag (to serve gRPC on a separate address)
	funcTestCmd.PersistentFlags().StringVar(&grpcServerAddress, "grpc-address", "", "gRPC server address")

	// HTTP/1.1 address flag (to serve HTTP on a separate address)
	funcTestCmd.PersistentFlags().StringVar(&httpServerAddress, "http-address", "", "HTTP server address")

	// CA certificate
	funcTestCmd.PersistentFlags().StringVar(&caCertificate, "ca", "", "X.509 certificate of the Certificate Authority (required for gRPC TLS support)")

	// gRPC client certificate
	funcTestCmd.PersistentFlags().StringVar(&serverCertificate, "cert", "", "X.509 certificate (required for gRPC TLS support)")

	// gRPC client private key
	funcTestCmd.PersistentFlags().StringVar(&serverPrivateKey, "key", "", "RSA private key (required for gRPC TLS support)")

	// JSON Web Token
	funcTestCmd.PersistentFlags().StringVar(&jwtToken, "jwt", "", "JSON Web Token (external server only)")

	// JWT secret signing key
	funcTestCmd.PersistentFlags().StringVar(&jwtSecret, "jwt-secret", "", "JSON Web Token secret signing key (embedded server only)")

	// request timeout
	funcTestCmd.PersistentFlags().IntVar(&timeoutSeconds, "timeout", 5, "Request timeout in seconds")

	// embedded server flag
	funcTestCmd.PersistentFlags().BoolVarP(&useEmbeddedServer, "embed-server", "e", false, "Embed the server to test")

	// random port server flag
	funcTestCmd.PersistentFlags().BoolVar(&useRandomPort, "random-port", false, "Use a random port for the embedded server")

	{{ range .DbTypes }}// {{ upperPascalCase . }} data migration on start
	funcTestCmd.PersistentFlags().BoolVar(&{{ lowerPascalCase . }}FunctestMigrate, "{{ lower . }}-migrate", false, "{{ upperPascalCase . }} data migration on start")
	{{ if eq . "mysql" }}// {{ upperPascalCase . }} data source name: https://github.com/go-sql-driver/{{ lower . }}#dsn-data-source-name
	funcTestCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} connection informations (USERNAME:PASSWORD@tcp(HOSTNAME:3306)/DBNAME)")
	{{ else if eq . "postgres" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	funcTestCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} connection informations (host=HOSTNAME port=DBPORT user=USERNAME dbname=DBNAME password=PASSWORD)")
	{{ else if eq . "sqlite" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	funcTestCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} data source file")
	{{ else if eq . "mssql" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	funcTestCmd.PersistentFlags().StringVar(&{{ lowerPascalCase . }}DataSourceName, "{{ lower . }}-dsn", "", "{{ upperPascalCase . }} connection informations (sqlserver://USERNAME:PASSWORD@tcp(HOSTNAME:1433)?database=DBNAME)")
	{{ end }}{{ end -}}
}

// getFreePort asks the kernel for a free open port that is ready to use.
func getFreePort() (int, error) {
	addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
	if err != nil {
		return 0, err
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return 0, err
	}
	defer l.Close()
	return l.Addr().(*net.TCPAddr).Port, nil
}

func runFunctionalTests() {
	if useEmbeddedServer {
		if debugMode {
			log.SetLevel(log.DebugLevel)
		} else {
			// by default for embedded server only panic are logged
			log.SetLevel(log.PanicLevel)
		}
		if useRandomPort {
			freePort, err := getFreePort()
			if err == nil {
				serverAddress = fmt.Sprintf("localhost:%d", freePort)
				grpcServerAddress = ""
				httpServerAddress = ""
			}
		}
		if grpcServerAddress != "" && httpServerAddress != "" {
			go serveOnMultipleAddresses(grpcServerAddress, httpServerAddress)
		} else {
			go serveOnSingleAddress(serverAddress)
		}
	}

	// if the embedded server is JWT-enabled, test clients require a valid token
	if useEmbeddedServer && jwtSecret != "" {
		var err error
		jwtToken, err = jwt.Create(
			"{{ .GomeetPkg }}",
			secretSigningKey,
			tokenLifetimeHours,
			subjectID,
			jwt.Claims{},
		)

		if err != nil {
			fmt.Printf("failed to create JWT : %v\n", err)
			os.Exit(1)
		}
	}
	{{ range .DbTypes }}
	// initialize the {{ lower . }} database schema
	if {{ lowerPascalCase . }}DataSourceName != "" && {{ lowerPascalCase . }}FunctestMigrate {
		{{ if eq . "mysql" }}if strings.Contains({{ lowerPascalCase . }}DataSourceName, "?") {
			fmt.Println("database connection error: data source name cannot contain options")
			os.Exit(1)
		}
		{{ lowerPascalCase . }}DSN := fmt.Sprintf("%s?charset=utf8&parseTime=True", {{ lowerPascalCase . }}DataSourceName)
		{{/* else if eq . "postgres" }} {{ else if eq . "sqlite" }} {{ else if eq . "mssql" */}}
		{{ else }}{{ lowerPascalCase . }}DSN := {{ lowerPascalCase . }}DataSourceName
		{{ end }}
		{{ lowerPascalCase . }}DB, err := gorm.Open("{{ lower . }}", {{ lowerPascalCase . }}DSN)
		if err != nil {
			fmt.Printf("Database connection error (DSN \"%s\"): %v\n", {{ lowerPascalCase . }}DSN, err)
			os.Exit(1)
		}
		// ping the {{ lower . }} database server
		err = {{ lowerPascalCase . }}DB.DB().Ping()
		if err != nil {
			fmt.Printf("Ping database connection error (DSN \"%s\"): %v\n", {{ lowerPascalCase . }}DSN, err)
			os.Exit(1)
		}
		{{ if eq (len $.DbTypes) 1 }}err = models.MigrateSchema({{ lowerPascalCase . }}DataSourceName)
		{{ else }}err = models.MigrateSchema("{{ lower . }}", {{ lowerPascalCase . }}DataSourceName){{ end }}
		if err != nil {
			fmt.Printf("{{ upperPascalCase . }} schema migration error: %s\n", err)
			os.Exit(1)
		}
	}
	{{ end }}
	testConfig := functest.FunctionalTestConfig{
		ServerAddress:     serverAddress,
		GrpcServerAddress: grpcServerAddress,
		HttpServerAddress: httpServerAddress,
		CaCertificate:     caCertificate,
		ClientCertificate: serverCertificate,
		ClientPrivateKey:  serverPrivateKey,
		TimeoutSeconds:    timeoutSeconds,
		JsonWebToken:      jwtToken,
		{{ range .DbTypes }}{{ upperPascalCase . }}DataSourceName: {{ lowerPascalCase . }}DataSourceName,
		{{ end }}
	}

	failures := runFunctionalTestSession(testConfig)

	if len(failures) == 0 {
		fmt.Println("PASS")
		fmt.Println("ok\tfunctest is ok")

		os.Exit(0)
	} else {
		fmt.Printf("Test failures:\n")
		for idx, failure := range failures {
			fmt.Printf("%d) %s: %s\n", idx+1, failure.Procedure, failure.Message)
		}

		os.Exit(1)
	}
}

func appendFailures(acc []functest.TestFailure, newSlice []functest.TestFailure) []functest.TestFailure {
	for _, failure := range newSlice {
		acc = append(acc, failure)
	}

	return acc
}

func runFunctionalTestSession(config functest.FunctionalTestConfig) []functest.TestFailure {
	var failures []functest.TestFailure

	// gRPC services test
{{- runFunctionalTestSession .Name .ProtoFiles -}}

	// Extra http handler
	failures = appendFailures(failures, functest.TestHttpStatus(config))
	failures = appendFailures(failures, functest.TestHttpMetrics(config))
	failures = appendFailures(failures, functest.TestHttpSwagger(config))

	return failures
}
