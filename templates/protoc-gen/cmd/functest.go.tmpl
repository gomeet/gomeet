// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
package cmd

import (
	"fmt"
	"net"
	"os"

	"github.com/spf13/cobra"
	log "github.com/sirupsen/logrus"

	"{{ .GomeetPkg }}/utils/jwt"

	"{{ .GoPkg }}/server"
	"{{ .GoPkg }}/cmd/functest"
)

var (
	useEmbeddedServer bool
	useRandomPort     bool

	// funcTestCmd represents the functest command
	funcTestCmd = &cobra.Command{
		Use:   "functest",
		Short: "Runs functional tests on the service",
		PreRun: bindFlagsToConfig,
		Run: runFunctionalTests,
	}
)

func init() {
	// embedded server flag
	funcTestCmd.PersistentFlags().BoolVarP(&useEmbeddedServer, "embed-server", "e", false, "Embed the server to test")
	// random port server flag
	funcTestCmd.PersistentFlags().BoolVar(&useRandomPort, "random-port", false, "Use a random port for the embedded server")

	initDebugFlag(funcTestCmd)
	initJWTSecretFlag(funcTestCmd)
	initJWTTokenFlag(funcTestCmd)
	initTimeoutFlag(funcTestCmd)
	initServerAddressFlag(funcTestCmd)

	//initClientTlsFlags(funcTestCmd)
	initWithTlsFlag(funcTestCmd)

	initGrpcFlags(funcTestCmd)
	initServerExtraFlags(funcTestCmd)
	initServerNetworkFlags(funcTestCmd)
	initServerSubServicesNetworkFlags(funcTestCmd)
	initServerTlsFlags(funcTestCmd)
	initServerQueueFlags(funcTestCmd)
	initDbDNSFlags(funcTestCmd)
	initDbMigrateFlags(funcTestCmd)

	rootCmd.AddCommand(funcTestCmd)
}

// getFreePort asks the kernel for a free open port that is ready to use.
func getFreePort() (int, error) {
	addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
	if err != nil {
		return 0, err
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return 0, err
	}
	defer l.Close()
	return l.Addr().(*net.TCPAddr).Port, nil
}

func runFunctionalTests(cmd *cobra.Command, args []string) {
	// TODO: GOMEET use config.Get
	if useEmbeddedServer {
		if debugMode {
			log.SetLevel(log.DebugLevel)
		} else {
			// by default for embedded server only panic are logged
			log.SetLevel(log.PanicLevel)
		}
		if useRandomPort {
			freePort, err := getFreePort()
			if err == nil {
				serverAddress = fmt.Sprintf("localhost:%d", freePort)
				grpcServerAddress = ""
				httpServerAddress = ""
			}
		}
		go func() {
			var ok bool
			if grpcServerAddress != "" && httpServerAddress != "" {
				ok = server.OnMultipleAddresses(
					grpcServerAddress, httpServerAddress,
					corsAllowedOrigins,
					caCertificate, serverCertificate, serverPrivateKey, jwtSecret, maxRecvMsgSize, maxSendMsgSize,
					{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName, {{ end -}}
					{{ range .QueueTypes }}{{ if eq . "memory" }}{{ lowerPascalCase . }}QueueWorkerCount, {{ lowerPascalCase . }}QueueMaxSize,
					{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
					{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
					{{ else if eq . "sqs" }}// sqs support is not yet implemented
					{{ end }}{{ end }}
					{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag, {{ end -}}
					{{ if .SubServices -}}{{ range .SubServices }}{{ $ss := . }}svc{{ upperPascalCase .ShortName }}Address, svc{{ upperPascalCase .ShortName }}Tls,
					{{ range .DbTypes }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, {{ end -}}
					{{ range .QueueTypes }}{{ if eq . "memory" }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount, svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize,
					{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
					{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
					{{ else if eq . "sqs" }}// sqs support is not yet implemented
					{{ end }}{{ end }}{{ range .ExtraServeFlags }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag, {{ end }}{{ end }}
				{{ end }})
			} else {
				ok = server.OnSingleAddress(
					serverAddress,
					corsAllowedOrigins,
					caCertificate, serverCertificate, serverPrivateKey, jwtSecret, maxRecvMsgSize, maxSendMsgSize,
					{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName, {{ end -}}
					{{ range .QueueTypes }}{{ if eq . "memory" }}{{ lowerPascalCase . }}QueueWorkerCount, {{ lowerPascalCase . }}QueueMaxSize,
					{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
					{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
					{{ else if eq . "sqs" }}// sqs support is not yet implemented
					{{ end }}{{ end }}
					{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag, {{ end -}}
					{{ if .SubServices -}}{{ range .SubServices }}{{ $ss := . }}svc{{ upperPascalCase .ShortName }}Address, svc{{ upperPascalCase .ShortName }}Tls,
					{{ range .DbTypes }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, {{ end -}}
					{{ range .QueueTypes }}{{ if eq . "memory" }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount, svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize,
					{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
					{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
					{{ else if eq . "sqs" }}// sqs support is not yet implemented
					{{ end }}{{ end }}{{ range .ExtraServeFlags }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag, {{ end }}{{ end }}
				{{ end }})
			}
			if !ok {
				log.Errorf("{{ upperPascalCase .Name }} starting failure: grpcServerAddress: %s, httpServerAddress: %s\n", grpcServerAddress, httpServerAddress)
			}
		}()
	}

	// if the embedded server is JWT-enabled, test clients require a valid token
	if useEmbeddedServer && jwtSecret != "" {
		var err error
		jwtToken, err = jwt.Create(
			"{{ .GomeetPkg }}",
			jwtSecret,
			tokenLifetimeHours,
			subjectID,
			jwt.Claims{},
		)

		if err != nil {
			fmt.Printf("failed to create JWT : %v\n", err)
			os.Exit(1)
		}
	}
	// databases migration
	databaseMigration()

	//initialize config
	testConfig := functest.FunctionalTestConfig{
		ServerAddress:      serverAddress,
		GrpcServerAddress:  grpcServerAddress,
		HttpServerAddress:  httpServerAddress,
		CaCertificate:      caCertificate,
		ClientCertificate:  serverCertificate,
		ClientPrivateKey:   serverPrivateKey,
		TimeoutSeconds:     timeoutSeconds,
		JsonWebTokenSecret: jwtSecret,
		JsonWebToken:       jwtToken,
		MaxRecvMsgSize:     maxRecvMsgSize,
		MaxSendMsgSize:     maxSendMsgSize,
		WithTls:            withTls,
		TokenLifetimeHours: tokenLifetimeHours,
		SubjectID:          subjectID,
		IsEmbeddedServer:   useEmbeddedServer,
		IsRandomPort:       useRandomPort,

		//extra parameters
		{{ range .DbTypes }}{{ upperPascalCase . }}DataSourceName: {{ lowerPascalCase . }}DataSourceName,
		{{ end }}
		{{ range .QueueTypes }}{{ if eq . "memory" }}{{ upperPascalCase . }}QueueWorkerCount:  {{ lowerPascalCase . }}QueueWorkerCount,
		{{ upperPascalCase . }}QueueMaxSize:  {{ lowerPascalCase . }}QueueMaxSize,
		{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
		{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
		{{ else if eq . "sqs" }}// sqs support is not yet implemented{{ end }}{{ end }}{{ range .ExtraServeFlags }}
		{{ upperPascalCase .Name }}ExtraFlag: {{ lowerPascalCase .Name }}ExtraFlag,{{ end }}{{ if .SubServices }}{{ range .SubServices }}{{ $ss := . }}
		Svc{{ upperPascalCase .ShortName }}Address: svc{{ upperPascalCase .ShortName }}Address,
		Svc{{ upperPascalCase .ShortName }}Tls: svc{{ upperPascalCase .ShortName }}Tls,{{ range .DbTypes }}
		Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName: svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName,
		{{ end }}{{ range .QueueTypes }}{{ if eq . "memory" }}
		Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount:  svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount,
		Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize:  svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize,
		{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
		{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
		{{ else if eq . "sqs" }}// sqs support is not yet implemented{{ end }}{{ end }}{{ range .ExtraServeFlags }}
		Svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag: svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag,
{{ end }}{{ end }}{{ end }}	}

	failures := runFunctionalTestSession(testConfig)

	if len(failures) == 0 {
		fmt.Println("PASS")
		fmt.Println("ok\tfunctest is ok")

		os.Exit(0)
	} else {
		fmt.Printf("Test failures:\n")
		for idx, failure := range failures {
			fmt.Printf("%d) %s: %s\n", idx+1, failure.Procedure, failure.Message)
		}

		os.Exit(1)
	}
}

func appendFailures(acc []functest.TestFailure, newSlice []functest.TestFailure) []functest.TestFailure {
	for _, failure := range newSlice {
		acc = append(acc, failure)
	}

	return acc
}

func runFunctionalTestSession(config functest.FunctionalTestConfig) []functest.TestFailure {
	var failures []functest.TestFailure

	// gRPC services test
{{- runFunctionalTestSession .Name .ProtoFiles -}}

	// Extra http handler
	failures = appendFailures(failures, functest.TestHttpStatus(config))
	failures = appendFailures(failures, functest.TestHttpMetrics(config))
	failures = appendFailures(failures, functest.TestHttpSwagger(config))

	return failures
}
