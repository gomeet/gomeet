// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
package cmd

import (
	"crypto/tls"
	"crypto/x509"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"strings"

	"github.com/auth0/go-jwt-middleware"
	"github.com/cockroachdb/cmux"
	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
	"github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus"
	"github.com/grpc-ecosystem/go-grpc-middleware/recovery"
	"github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/grpc-ecosystem/go-grpc-middleware/validator"
	"github.com/grpc-ecosystem/go-grpc-prometheus"
	nlog "github.com/meatballhat/negroni-logrus"
	"github.com/rs/cors"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/urfave/negroni"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"

	grpc_acl "{{ .GomeetPkg }}/utils/grpc-middlewares/acl"
	grpc_cid "{{ .GomeetPkg }}/utils/grpc-middlewares/cid"
)

var (
	// SUB-SERVICES DEFINITION : var-address
	// svc{{ "{{SubServiceNamePascalCase}}" }}Address string
	{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address string
	{{ end }}// END SUB-SERVICES DEFINITION : var-address

	// microCmd represents the serve micro command
	microCmd = &cobra.Command{
		Use:   "micro",
		Short: "Launches the {{ .Name }} service webserver has a micro service",
		Run: func(cmd *cobra.Command, args []string) {
			micro()
		},
	}
)

func init() {
	serveCmd.AddCommand(microCmd)

	// Here you will define your flags and configuration settings.

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:

	// SUB-SERVICES DEFINITION : flag-address
	// // {{ "{{SubServiceNamePascalCase}}" }} service address
	// microCmd.PersistentFlags().StringVar(&svc{{ "{{SubServiceNamePascalCase}}" }}Address, "svc-{{ "{{SubServiceNameKebabCase}}" }}-address", "", "{{ "{{SubServiceNamePascalCase}}" }} service address (host:port)")

	{{ range .SubServices }}// {{ upperPascalCase .ShortName }} service address
	microCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase .ShortName }}Address, "svc-{{ lowerKebabCase .ShortName }}-address", "", "{{ upperPascalCase .ShortName }} service address (host:port)")

	{{ end }}// END SUB-SERVICES DEFINITION : flag-address

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// microCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

func micro() {
	if strings.HasSuffix(svc.Version, "+dev") || debugMode {
		log.SetLevel(log.DebugLevel)
		log.WithFields(log.Fields{
			"Name":     svc.Name,
			"Version":  svc.Version,
			"FullName": svcName,
		}).Debug("set log debug level")
	}

	log.Infof("%s version %s - %s", svc.Name, svc.Version, svcName)

	databaseMigration()

	if grpcServerAddress != "" && httpServerAddress != "" {
		microOnMultipleAddresses(grpcServerAddress, httpServerAddress)
	} else {
		microOnSingleAddress(serverAddress)
	}
}

func grpcServer(
	caCert string,
	serverCert string,
	serverKey string,
	jwtKey string,
	// EXTRA : param
	{{ range .DbTypes }}{{ lowerPascalCase . }}DSN string,
	{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag {{ .Type }},
	{{ end }}// END EXTRA : param
	// SUB-SERVICES DEFINITION : param-address
	// svc{{ "{{SubServiceNamePascalCase}}" }}Address string,
	{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address string,
	{{ end }}// END SUB-SERVICES DEFINITION : param-address
) *grpc.Server {
	var grpcS *grpc.Server

	//middlewares definition
	recoveryOpt := grpc_recovery.WithRecoveryHandler(recoverFromPanic)
	logrusEntry := log.NewEntry(log.StandardLogger())
	// stream middlewares
	sMdl := grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
		grpc_prometheus.StreamServerInterceptor,
		grpc_cid.StreamServerInterceptor(false),
		grpc_ctxtags.StreamServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
		grpc_logrus.StreamServerInterceptor(logrusEntry),
		grpc_auth.StreamServerInterceptor(nil),
		grpc_validator.StreamServerInterceptor(),
		grpc_acl.StreamServerInterceptor(nil),
		grpc_recovery.StreamServerInterceptor(recoveryOpt),
	))
	// unary middlewares
	uMdl := grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		grpc_prometheus.UnaryServerInterceptor,
		grpc_cid.UnaryServerInterceptor(false),
		grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
		grpc_logrus.UnaryServerInterceptor(logrusEntry),
		grpc_auth.UnaryServerInterceptor(nil),
		grpc_validator.UnaryServerInterceptor(),
		grpc_acl.UnaryServerInterceptor(nil),
		grpc_recovery.UnaryServerInterceptor(recoveryOpt),
	))

	if caCert != "" && serverCert != "" && serverKey != "" {
		// load the server's key pair
		serverKeyPair, err := tls.LoadX509KeyPair(serverCert, serverKey)
		if err != nil {
			log.Fatalf("failed to load gateway key pair: %v", err)
		}

		// create a certificate pool from the CA
		certPool := x509.NewCertPool()
		ca, err := ioutil.ReadFile(caCert)
		if err != nil {
			log.Fatalf("failed to read CA certificate: %v", err)
		}
		if ok := certPool.AppendCertsFromPEM(ca); !ok {
			log.Fatalf("failed to build certificate pool")
		}

		// set up the TLS credentials
		serverCredentials := credentials.NewTLS(&tls.Config{
			ClientAuth:   tls.RequireAndVerifyClientCert,
			Certificates: []tls.Certificate{serverKeyPair},
			ClientCAs:    certPool,
		})

		grpcS = grpc.NewServer(grpc.Creds(serverCredentials), sMdl, uMdl)
	} else {
		grpcS = grpc.NewServer(sMdl, uMdl)
	}

	svc.RegisterGRPCServices(
		grpcS,
		jwtKey,
		caCert,
		serverCert,
		serverKey,
		// EXTRA : register
		{{ range .DbTypes }}{{ lowerPascalCase . }}DSN,
		{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}// END EXTRA : register
		// SUB-SERVICES DEFINITION : register-address
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address
	)
	grpc_prometheus.Register(grpcS)

	return grpcS
}

func httpServer(httpServerAddr string, grpcServerAddr string, ctx context.Context, caCert string, gatewayCert string, gatewayKey string, jwtKey string) *http.Server {
	// create the HTTP request router
	h := mux.NewRouter()

	// register the gRPC gateway
	var opts []grpc.DialOption
	if caCert != "" && gatewayCert != "" && gatewayKey != "" {
		// load the gateway's key pair
		gatewayKeyPair, err := tls.LoadX509KeyPair(gatewayCert, gatewayKey)
		if err != nil {
			log.Fatalf("failed to load client key pair: %v", err)
		}

		// create a certificate pool from the CA
		certPool := x509.NewCertPool()
		ca, err := ioutil.ReadFile(caCert)
		if err != nil {
			log.Fatalf("failed to read CA certificate: %v", err)
		}
		if ok := certPool.AppendCertsFromPEM(ca); !ok {
			log.Fatalf("failed to build certificate pool")
		}

		// set up the TLS credentials
		serverHost, _, err := net.SplitHostPort(grpcServerAddr)
		if err != nil {
			log.Fatalf("failed to parse server hostname in %s: %v", grpcServerAddr, err)
		}
		if serverHost == "" {
			serverHost = "localhost"
		}
		gatewayCredentials := credentials.NewTLS(&tls.Config{
			ServerName:   serverHost,
			Certificates: []tls.Certificate{gatewayKeyPair},
			RootCAs:      certPool,
		})

		opts = []grpc.DialOption{grpc.WithTransportCredentials(gatewayCredentials)}
	} else {
		opts = []grpc.DialOption{grpc.WithInsecure()}
	}

	// register other HTTP handlers
	if jwtKey != "" {
		// setup the JWT authentication middleware
		jwtMiddleware := jwtmiddleware.New(jwtmiddleware.Options{
			ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {
				return []byte(jwtKey), nil
			},
			SigningMethod: jwt.SigningMethodHS256,
		})

		svc.RegisterHTTPServices(ctx, h, grpcServerAddr, opts, jwtMiddleware)
	} else {
		svc.RegisterHTTPServices(ctx, h, grpcServerAddr, opts, nil)
	}

	// setup the negroni middleware for request logging
	n := negroni.New(
		// no crash with 500
		negroni.NewRecovery(),
		// global logrus logger
		nlog.NewMiddlewareFromLogger(log.StandardLogger(), "{{ .Name }}"),
	)

	// CORS support
	if corsAllowedOrigins != "" {
		log.Infof("HTTP with Cross Origin Resource Sharing, AllowedOrigins: %s", corsAllowedOrigins)
		n.Use(cors.New(cors.Options{
			AllowedOrigins: strings.Split(corsAllowedOrigins, "|"),
		}))
	}

	n.UseHandler(h)

	return &http.Server{Handler: n}
}

func microOnMultipleAddresses(grpcAddr string, httpAddr string) {
	// create the gRPC server
	grpcS := grpcServer(
		caCertificate,
		serverCertificate,
		serverPrivateKey,
		jwtSecret,
		// EXTRA : register
		{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName,
		{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}// END EXTRA : register
		// SUB-SERVICES DEFINITION : register-address
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address
	)

	// create the gRPC listener
	grpcL, err := net.Listen("tcp", grpcAddr)
	if err != nil {
		log.Fatal(err)
	}

	// create the HTTP/1.1 server (we reuse the gRPC server's key pair for the gRPC gateway client)
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	httpS := httpServer(httpAddr, grpcAddr, ctx, caCertificate, serverCertificate, serverPrivateKey, jwtSecret)

	// create the HTTP listener
	httpL, err := net.Listen("tcp", httpAddr)
	if err != nil {
		log.Fatal(err)
	}

	// HTTPS support
	if caCertificate != "" && serverCertificate != "" && serverPrivateKey != "" {
		// load the server's key pair
		serverKeyPair, err := tls.LoadX509KeyPair(serverCertificate, serverPrivateKey)
		if err != nil {
			log.Fatalf("failed to load HTTPS server key pair: %v", err)
		}

		tlsConfig := &tls.Config{
			Certificates: []tls.Certificate{serverKeyPair},
			ClientAuth:   tls.NoClientCert,
		}

		httpsL := tls.NewListener(httpL, tlsConfig)
		httpL = httpsL
	}

	// collect on this channel the exits of each protocol's .Serve() call
	eps := make(chan error, 2)
	// start the listeners for each protocol
	go func() { eps <- grpcS.Serve(grpcL) }()
	go func() { eps <- httpS.Serve(httpL) }()

	grpcSecurity := "insecure"
	if caCertificate != "" && serverCertificate != "" && serverPrivateKey != "" {
		grpcSecurity = "secure"
	}
	jwtSupport := "disabled"
	if jwtSecret != "" {
		jwtSupport = "enabled"
	}
	log.Infof("serving %s gRPC on %s and %s HTTP/1.1 on %s (JWT %s)", grpcSecurity, grpcAddr, grpcSecurity, httpAddr, jwtSupport)

	// handle listener errors
	failed := false
	i := 0
	for err := range eps {
		if err != nil {
			log.Errorf("protocol serve error: %v", err)
			failed = true
		}
		i++
		if i == cap(eps) {
			close(eps)
			break
		}
	}
	if failed {
		os.Exit(1)
	}
}

func microOnSingleAddress(addr string) {
	// listen on the specified address
	l, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatal(err)
	}

	// create the cmux object that will multiplex 2 protocols on the same port
	m := cmux.New(l)
	// match HTTP/1.1 requests and gRPC requests
	httpL := m.Match(cmux.HTTP1())
	grpcL := m.Match(cmux.Any())

	// create the gRPC server
	grpcS := grpcServer(
		caCertificate,
		serverCertificate,
		serverPrivateKey,
		jwtSecret,
		// EXTRA : register
		{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName,
		{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}// END EXTRA : register
		// SUB-SERVICES DEFINITION : register-address
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address
	)

	// create the HTTP/1.1 server (we reuse the gRPC server's key pair for the gRPC gateway client)
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	httpS := httpServer(addr, addr, ctx, caCertificate, serverCertificate, serverPrivateKey, jwtSecret)

	// collect on this channel the exits of each protocol's .Serve() call
	eps := make(chan error, 2)
	// start the listeners for each protocol
	go func() { eps <- grpcS.Serve(grpcL) }()
	go func() { eps <- httpS.Serve(httpL) }()

	grpcSecurity := "insecure"
	if caCertificate != "" && serverCertificate != "" && serverPrivateKey != "" {
		grpcSecurity = "secure"
	}
	jwtSupport := "disabled"
	if jwtSecret != "" {
		jwtSupport = "enabled"
	}
	log.Infof("serving on %s (multiplexed, %s gRPC, JWT %s)", addr, grpcSecurity, jwtSupport)
	err = m.Serve()

	// the rest of the code handles exit errors of the muxes
	failed := false
	i := 0
	for err := range eps {
		if err != nil {
			log.Errorf("protocol serve error: %v", err)
			failed = true
		}
		i++
		if i == cap(eps) {
			close(eps)
			break
		}
	}
	if failed {
		os.Exit(1)
	}
}
