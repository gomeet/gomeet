// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
package cmd

import (
	"os"
	"strings"

	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"

	{{ range .SubServices }}{{ $ss := . }}{{ if .DbTypes }}svc{{ upperPascalCase $ss.ShortName }}Models "{{ $ss.GoPkg }}/models"
	{{ end }}{{ end }}
	{{ if .DbTypes }}"{{ .GoPkg }}/models"{{ end }}
	"{{ .GoPkg }}/server"
)

var (
	// serveCmd represents the serve serve command
	serveCmd = &cobra.Command{
		Use:   "serve",
		Short: "Launches the {{ .Name }} service webserver",
		{{if .SubServices }}Long: `Launches the {{ .Name }} service webserver

Warning on embed sub-services:

{{ .SubServicesMonolithHelp }}
`,{{ end }}
		PreRun: bindFlagsToConfig,
		Run: serve,
	}
)

func init() {
	initDebugFlag(serveCmd)
	initJWTSecretFlag(serveCmd)
	// initJWTTokenFlag(serveCmd)
	// initTimeoutFlag(serveCmd)
	initServerAddressFlag(serveCmd)

	initGrpcFlags(serveCmd)
	initServerExtraFlags(serveCmd)
	initServerNetworkFlags(serveCmd)
	initServerSubServicesNetworkFlags(serveCmd)
	initServerTlsFlags(serveCmd)
	initServerQueueFlags(serveCmd)
	initDbDNSFlags(serveCmd)
	initDbMigrateFlags(serveCmd)

	rootCmd.AddCommand(serveCmd)
}

func databaseMigration() {
	// TODO: GOMEET use config.Get
	//SubServices databaseMigration
	{{ range .SubServices }}{{ if .DbTypes }}svc{{ upperPascalCase .ShortName }}DatabaseMigration(){{ end }}
	{{ end }}

	{{ range .DbTypes }}// {{ upperPascalCase . }} data migration on start
	if {{ lowerPascalCase . }}Migrate {
		if {{ lowerPascalCase . }}DataSourceName == "" {
			log.Errorf("The --{{ lower . }}-dsn flag is required for automatic schema migration")
			os.Exit(1)
		}

		{{ if eq (len $.DbTypes) 1 }}err := models.MigrateSchema({{ lowerPascalCase . }}DataSourceName)
		{{ else }}err := models.MigrateSchema("{{ lower . }}", {{ lowerPascalCase . }}DataSourceName){{ end }}
		if err != nil {
			log.Errorf("Database schema migration failure: %v\n", err)
			os.Exit(1)
		}
	}{{ end }}
}

{{ range .SubServices }}{{ $ss := . }}{{ if .DbTypes }}
func svc{{ upperPascalCase .ShortName }}DatabaseMigration() {
	// TODO: GOMEET use config.Get
	{{ range .DbTypes }}// {{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }} data migration on start
	if svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}Migrate {
		if svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName == "" {
			log.Errorf("The --svc-{{ lowerPascalCase $ss.ShortName }}-{{ lower . }}-dsn flag is required for automatic schema migration")
			os.Exit(1)
		}
		{{ if eq (len $ss.DbTypes) 1 }}err := svc{{ upperPascalCase $ss.ShortName }}Models.MigrateSchema(svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName)
		{{ else }}err := svc{{ upperPascalCase $ss.ShortName }}Models.MigrateSchema("{{ lower . }}", svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName){{ end }}
		if err != nil {
			log.Errorf("svc{{ upperPascalCase $ss.ShortName }} Database schema migration failure: %v\n", err)
			os.Exit(1)
		}
	}{{ end }}
}
{{ end }}{{ end }}

func serve(cmd *cobra.Command, args []string) {
	// TODO: GOMEET use config.Get
	if strings.HasSuffix(svc.Version, "+dev") || debugMode {
		log.SetLevel(log.DebugLevel)
		log.WithFields(log.Fields{
			"Name":     svc.Name,
			"Version":  svc.Version,
			"FullName": svcName,
		}).Debug("set log debug level")
	}

	log.Infof("%s version %s - %s", svc.Name, svc.Version, svcName)

	databaseMigration()
	var ok bool
	if grpcServerAddress != "" && httpServerAddress != "" {
		ok = server.OnMultipleAddresses(
			grpcServerAddress, httpServerAddress,
			corsAllowedOrigins,
			caCertificate, serverCertificate, serverPrivateKey, jwtSecret, maxRecvMsgSize, maxSendMsgSize,
			{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName, {{ end -}}
			{{ range .QueueTypes }}{{ if eq . "memory" }}{{ lowerPascalCase . }}QueueWorkerCount, {{ lowerPascalCase . }}QueueMaxSize,
			{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
			{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
			{{ else if eq . "sqs" }}// sqs support is not yet implemented
			{{ end }}{{ end }}
			{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag, {{ end -}}
			{{ if .SubServices -}}{{ range .SubServices }}{{ $ss := . }}svc{{ upperPascalCase .ShortName }}Address, svc{{ upperPascalCase .ShortName }}Tls,
			{{ range .DbTypes }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, {{ end -}}
			{{ range .QueueTypes }}{{ if eq . "memory" }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount, svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize,
			{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
			{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
			{{ else if eq . "sqs" }}// sqs support is not yet implemented
			{{ end }}{{ end }}{{ range .ExtraServeFlags }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag, {{ end }}{{ end }}
		{{ end }})
	} else {
		ok = server.OnSingleAddress(
			serverAddress,
			corsAllowedOrigins,
			caCertificate, serverCertificate, serverPrivateKey, jwtSecret, maxRecvMsgSize, maxSendMsgSize,
			{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName, {{ end -}}
			{{ range .QueueTypes }}{{ if eq . "memory" }}{{ lowerPascalCase . }}QueueWorkerCount, {{ lowerPascalCase . }}QueueMaxSize,
			{{ else if eq . "rabbitmq" }}// rabbitmq support is not yet implemented
			{{ else if eq . "zeromq" }}// zeromq support is not yet implemented
			{{ else if eq . "sqs" }}// sqs support is not yet implemented
			{{ end }}{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag, {{ end -}}
			{{ if .SubServices -}}{{ range .SubServices }}{{ $ss := . }}svc{{ upperPascalCase .ShortName }}Address, svc{{ upperPascalCase .ShortName }}Tls,
			{{ range .DbTypes }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, {{ end -}}
			{{ range .QueueTypes }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueWorkerCount, svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}QueueMaxSize, {{ end -}}
			{{ range .ExtraServeFlags }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}ExtraFlag, {{ end }}{{ end }}
		{{ end }})
	}
	if !ok {
		log.Errorf("{{ upperPascalCase .Name }} starting failure: grpcServerAddress: %s, httpServerAddress: %s\n", grpcServerAddress, httpServerAddress)
		os.Exit(1)
	}
}
