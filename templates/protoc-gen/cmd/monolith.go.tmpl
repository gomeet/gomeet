// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
package cmd

import (
	"crypto/tls"
	"crypto/x509"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"strings"

	"github.com/auth0/go-jwt-middleware"
	"github.com/cockroachdb/cmux"
	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
	"github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus"
	"github.com/grpc-ecosystem/go-grpc-middleware/recovery"
	"github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/grpc-ecosystem/go-grpc-middleware/validator"
	"github.com/grpc-ecosystem/go-grpc-prometheus"
	nlog "github.com/meatballhat/negroni-logrus"
	"github.com/rs/cors"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/urfave/negroni"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"

	grpc_acl "{{ .GomeetPkg }}/utils/grpc-middlewares/acl"
	grpc_cid "{{ .GomeetPkg }}/utils/grpc-middlewares/cid"
	{{ range .SubServices }}{{ if .DbTypes }}svc_{{ lowerSnakeCase .ShortName }}_models "{{ .GoPkg }}/models"{{ end }}
	{{ end }}

)

var (
	// SUB-SERVICES DEFINITION : var-monolith
	{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}MonolithAddress string
	{{ $ss := . }}{{ range .DbTypes }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}Migrate bool
	svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName string
	{{ end }}{{ range .ExtraServeFlags }}svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}MonolithExtraFlag {{ .Type }}
	{{ end }}{{ end }}// END SUB-SERVICES DEFINITION : var-monolith

	// monolithCmd represents the serve monolith command
	monolithCmd = &cobra.Command{
		Use:   "monolith",
		Short: "Launches the {{ .Name }} service webserver has a big monolith application",
		Run: func(cmd *cobra.Command, args []string) {
			monolith()
		},
	}
)

func init() {
	serveCmd.AddCommand(monolithCmd)

	// Here you will define your flags and configuration settings.

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:

	// SUB-SERVICES DEFINITION : flag-address
	{{ range .SubServices }}// {{ upperPascalCase .ShortName }} service address
	// EXTRA : flags
	monolithCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase .ShortName }}MonolithAddress, "svc-{{ lowerKebabCase .ShortName }}-address", "", "{{ upperPascalCase .ShortName }} service address (host:port) if empty, the sub-service is embed with svc-{{ lowerKebabCase .ShortName }}-* flags has parameters")
	{{ $ss := . }}{{ range .DbTypes }}// svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }} data migration on start
	monolithCmd.PersistentFlags().BoolVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}Migrate, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-migrate", false, "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} data migration on start")
	{{ if eq . "mysql" }}// {{ upperPascalCase . }} data source name: https://github.com/go-sql-driver/{{ lower . }}#dsn-data-source-name
	monolithCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} connection informations (USERNAME:PASSWORD@tcp(HOSTNAME:3306)/DBNAME)")
	{{ else if eq . "postgres" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	monolithCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} connection informations (host=HOSTNAME port=DBPORT user=USERNAME dbname=DBNAME password=PASSWORD)")
	{{ else if eq . "sqlite" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	monolithCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} data source file")
	{{ else if eq . "mssql" }}// {{ upperPascalCase . }} data source name: http://gorm.io/database.html#connecting-to-a-database
	monolithCmd.PersistentFlags().StringVar(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lower . }}-dsn", "", "svc{{ upperPascalCase $ss.ShortName }} {{ upperPascalCase . }} connection informations (sqlserver://USERNAME:PASSWORD@tcp(HOSTNAME:1433)?database=DBNAME)")
	{{ end }}{{ end }}{{ range .ExtraServeFlags }}// extra embed flag for $ss.ShortName
	monolithCmd.PersistentFlags().{{ title .Type }}Var(&svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase .Name }}MonolithExtraFlag, "svc-{{ lowerKebabCase $ss.ShortName }}-{{ lowerKebabCase .Name }}", {{ if eq .Type "string" }}"{{ end }}{{ .DefaultValue }}{{ if eq .Type "string" }}"{{ end }}, "{{ .Description }}")
	{{ end }}{{ end }}// END SUB-SERVICES DEFINITION : flag-address

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// monolithCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

{{ range .SubServices }}{{ if .DbTypes }}{{ $ss := . }}
func svc{{ upperPascalCase .ShortName }}DatabaseMigration() {
	{{ range .DbTypes }}// {{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }} data migration on start
	if svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}Migrate {
		if svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName == "" {
			log.Errorf("The --svc-{{ lowerPascalCase $ss.ShortName }}-{{ lower . }}-dsn flag is required for automatic schema migration")
			os.Exit(1)
		}
		{{ if eq (len $ss.DbTypes) 1 }}err := svc_{{ lowerSnakeCase $ss.ShortName }}_models.MigrateSchema(svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName)
		{{ else }}err := svc_{{ lowerSnakeCase $ss.ShortName }}_models.MigrateSchema("{{ lower . }}", svc{{ upperPascalCase $ss.ShortName }}{{ upperPascalCase . }}DataSourceName){{ end }}
		if err != nil {
			log.Errorf("svc{{ upperPascalCase $ss.ShortName }} Database schema migration failure: %v\n", err)
			os.Exit(1)
		}
	}{{ end }}
}
{{ end }}{{ end }}

func monolith() {
	if strings.HasSuffix(svc.Version, "+dev") || debugMode {
		log.SetLevel(log.DebugLevel)
		log.WithFields(log.Fields{
			"Name":     svc.Name,
			"Version":  svc.Version,
			"FullName": svcName,
		}).Debug("set log debug level")
	}

	log.Infof("%s version %s - %s", svc.Name, svc.Version, svcName)

	{{ range .SubServices }}{{ if .DbTypes }}svc{{ upperPascalCase .ShortName }}DatabaseMigration(){{ end }}
	{{ end }}databaseMigration()

	if grpcServerAddress != "" && httpServerAddress != "" {
		monolithOnMultipleAddresses(grpcServerAddress, httpServerAddress)
	} else {
		monolithOnSingleAddress(serverAddress)
	}
}

func grpcMonolithServer(
	caCert string,
	serverCert string,
	serverKey string,
	jwtKey string,
	// EXTRA : param
	{{ range .DbTypes }}{{ lowerPascalCase . }}DSN string,
	{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag {{ .Type }},
	{{ end }}// END EXTRA : param
	// SUB-SERVICES DEFINITION : param-address
	// svc{{ "{{SubServiceNamePascalCase}}" }}Address string,
	{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}MonolithAddress string,
	{{ end }}// END SUB-SERVICES DEFINITION : param-address
) *grpc.Server {
	var grpcS *grpc.Server

	//middlewares definition
	recoveryOpt := grpc_recovery.WithRecoveryHandler(recoverFromPanic)
	logrusEntry := log.NewEntry(log.StandardLogger())
	// stream middlewares
	sMdl := grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
		grpc_prometheus.StreamServerInterceptor,
		grpc_cid.StreamServerInterceptor(false),
		grpc_ctxtags.StreamServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
		grpc_logrus.StreamServerInterceptor(logrusEntry),
		grpc_auth.StreamServerInterceptor(nil),
		grpc_validator.StreamServerInterceptor(),
		grpc_acl.StreamServerInterceptor(nil),
		grpc_recovery.StreamServerInterceptor(recoveryOpt),
	))
	// unary middlewares
	uMdl := grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		grpc_prometheus.UnaryServerInterceptor,
		grpc_cid.UnaryServerInterceptor(false),
		grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
		grpc_logrus.UnaryServerInterceptor(logrusEntry),
		grpc_auth.UnaryServerInterceptor(nil),
		grpc_validator.UnaryServerInterceptor(),
		grpc_acl.UnaryServerInterceptor(nil),
		grpc_recovery.UnaryServerInterceptor(recoveryOpt),
	))

	if caCert != "" && serverCert != "" && serverKey != "" {
		// load the server's key pair
		serverKeyPair, err := tls.LoadX509KeyPair(serverCert, serverKey)
		if err != nil {
			log.Fatalf("failed to load gateway key pair: %v", err)
		}

		// create a certificate pool from the CA
		certPool := x509.NewCertPool()
		ca, err := ioutil.ReadFile(caCert)
		if err != nil {
			log.Fatalf("failed to read CA certificate: %v", err)
		}
		if ok := certPool.AppendCertsFromPEM(ca); !ok {
			log.Fatalf("failed to build certificate pool")
		}

		// set up the TLS credentials
		serverCredentials := credentials.NewTLS(&tls.Config{
			ClientAuth:   tls.RequireAndVerifyClientCert,
			Certificates: []tls.Certificate{serverKeyPair},
			ClientCAs:    certPool,
		})

		grpcS = grpc.NewServer(grpc.Creds(serverCredentials), sMdl, uMdl)
	} else {
		grpcS = grpc.NewServer(sMdl, uMdl)
	}

	svc.RegisterGRPCServices(
		grpcS,
		jwtKey,
		caCert,
		serverCert,
		serverKey,
		// EXTRA : register
		{{ range .DbTypes }}{{ lowerPascalCase . }}DSN,
		{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}// END EXTRA : register
		// SUB-SERVICES DEFINITION : register-address
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address
	)
	grpc_prometheus.Register(grpcS)

	return grpcS
}

func httpMonolithServer(httpServerAddr string, grpcServerAddr string, ctx context.Context, caCert string, gatewayCert string, gatewayKey string, jwtKey string) *http.Server {
	// create the HTTP request router
	h := mux.NewRouter()

	// register the gRPC gateway
	var opts []grpc.DialOption
	if caCert != "" && gatewayCert != "" && gatewayKey != "" {
		// load the gateway's key pair
		gatewayKeyPair, err := tls.LoadX509KeyPair(gatewayCert, gatewayKey)
		if err != nil {
			log.Fatalf("failed to load client key pair: %v", err)
		}

		// create a certificate pool from the CA
		certPool := x509.NewCertPool()
		ca, err := ioutil.ReadFile(caCert)
		if err != nil {
			log.Fatalf("failed to read CA certificate: %v", err)
		}
		if ok := certPool.AppendCertsFromPEM(ca); !ok {
			log.Fatalf("failed to build certificate pool")
		}

		// set up the TLS credentials
		serverHost, _, err := net.SplitHostPort(grpcServerAddr)
		if err != nil {
			log.Fatalf("failed to parse server hostname in %s: %v", grpcServerAddr, err)
		}
		if serverHost == "" {
			serverHost = "localhost"
		}
		gatewayCredentials := credentials.NewTLS(&tls.Config{
			ServerName:   serverHost,
			Certificates: []tls.Certificate{gatewayKeyPair},
			RootCAs:      certPool,
		})

		opts = []grpc.DialOption{grpc.WithTransportCredentials(gatewayCredentials)}
	} else {
		opts = []grpc.DialOption{grpc.WithInsecure()}
	}

	// register other HTTP handlers
	if jwtKey != "" {
		// setup the JWT authentication middleware
		jwtMiddleware := jwtmiddleware.New(jwtmiddleware.Options{
			ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {
				return []byte(jwtKey), nil
			},
			SigningMethod: jwt.SigningMethodHS256,
		})

		svc.RegisterHTTPServices(ctx, h, grpcServerAddr, opts, jwtMiddleware)
	} else {
		svc.RegisterHTTPServices(ctx, h, grpcServerAddr, opts, nil)
	}

	// setup the negroni middleware for request logging
	n := negroni.New(
		// no crash with 500
		negroni.NewRecovery(),
		// global logrus logger
		nlog.NewMiddlewareFromLogger(log.StandardLogger(), "{{ .Name }}"),
	)

	// CORS support
	if corsAllowedOrigins != "" {
		log.Infof("HTTP with Cross Origin Resource Sharing, AllowedOrigins: %s", corsAllowedOrigins)
		n.Use(cors.New(cors.Options{
			AllowedOrigins: strings.Split(corsAllowedOrigins, "|"),
		}))
	}

	n.UseHandler(h)

	return &http.Server{Handler: n}
}

func monolithOnMultipleAddresses(grpcAddr string, httpAddr string) {
	// create the gRPC server
	grpcS := grpcMonolithServer(
		caCertificate,
		serverCertificate,
		serverPrivateKey,
		jwtSecret,
		// EXTRA : register
		{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName,
		{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}// END EXTRA : register
		// SUB-SERVICES DEFINITION : register-address
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address
	)

	// create the gRPC listener
	grpcL, err := net.Listen("tcp", grpcAddr)
	if err != nil {
		log.Fatal(err)
	}

	// create the HTTP/1.1 server (we reuse the gRPC server's key pair for the gRPC gateway client)
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	httpS := httpServer(httpAddr, grpcAddr, ctx, caCertificate, serverCertificate, serverPrivateKey, jwtSecret)

	// create the HTTP listener
	httpL, err := net.Listen("tcp", httpAddr)
	if err != nil {
		log.Fatal(err)
	}

	// HTTPS support
	if caCertificate != "" && serverCertificate != "" && serverPrivateKey != "" {
		// load the server's key pair
		serverKeyPair, err := tls.LoadX509KeyPair(serverCertificate, serverPrivateKey)
		if err != nil {
			log.Fatalf("failed to load HTTPS server key pair: %v", err)
		}

		tlsConfig := &tls.Config{
			Certificates: []tls.Certificate{serverKeyPair},
			ClientAuth:   tls.NoClientCert,
		}

		httpsL := tls.NewListener(httpL, tlsConfig)
		httpL = httpsL
	}

	// collect on this channel the exits of each protocol's .Serve() call
	eps := make(chan error, 2)
	// start the listeners for each protocol
	go func() { eps <- grpcS.Serve(grpcL) }()
	go func() { eps <- httpS.Serve(httpL) }()

	grpcSecurity := "insecure"
	if caCertificate != "" && serverCertificate != "" && serverPrivateKey != "" {
		grpcSecurity = "secure"
	}
	jwtSupport := "disabled"
	if jwtSecret != "" {
		jwtSupport = "enabled"
	}
	log.Infof("serving %s gRPC on %s and %s HTTP/1.1 on %s (JWT %s)", grpcSecurity, grpcAddr, grpcSecurity, httpAddr, jwtSupport)

	// handle listener errors
	failed := false
	i := 0
	for err := range eps {
		if err != nil {
			log.Errorf("protocol serve error: %v", err)
			failed = true
		}
		i++
		if i == cap(eps) {
			close(eps)
			break
		}
	}
	if failed {
		os.Exit(1)
	}
}

func monolithOnSingleAddress(addr string) {
	// listen on the specified address
	l, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatal(err)
	}

	// create the cmux object that will multiplex 2 protocols on the same port
	m := cmux.New(l)
	// match HTTP/1.1 requests and gRPC requests
	httpL := m.Match(cmux.HTTP1())
	grpcL := m.Match(cmux.Any())

	// create the gRPC server
	grpcS := grpcMonolithServer(
		caCertificate,
		serverCertificate,
		serverPrivateKey,
		jwtSecret,
		// EXTRA : register
		{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName,
		{{ end }}{{ range .ExtraServeFlags }}{{ lowerPascalCase .Name }}ExtraFlag,
		{{ end }}// END EXTRA : register
		// SUB-SERVICES DEFINITION : register-address
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address
	)

	// create the HTTP/1.1 server (we reuse the gRPC server's key pair for the gRPC gateway client)
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	httpS := httpServer(addr, addr, ctx, caCertificate, serverCertificate, serverPrivateKey, jwtSecret)

	// collect on this channel the exits of each protocol's .Serve() call
	eps := make(chan error, 2)
	// start the listeners for each protocol
	go func() { eps <- grpcS.Serve(grpcL) }()
	go func() { eps <- httpS.Serve(httpL) }()

	grpcSecurity := "insecure"
	if caCertificate != "" && serverCertificate != "" && serverPrivateKey != "" {
		grpcSecurity = "secure"
	}
	jwtSupport := "disabled"
	if jwtSecret != "" {
		jwtSupport = "enabled"
	}
	log.Infof("serving on %s (multiplexed, %s gRPC, JWT %s)", addr, grpcSecurity, jwtSupport)
	err = m.Serve()

	// the rest of the code handles exit errors of the muxes
	failed := false
	i := 0
	for err := range eps {
		if err != nil {
			log.Errorf("protocol serve error: %v", err)
			failed = true
		}
		i++
		if i == cap(eps) {
			close(eps)
			break
		}
	}
	if failed {
		os.Exit(1)
	}
}
