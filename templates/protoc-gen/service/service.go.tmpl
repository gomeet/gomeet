// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source:{{ range .ProtoFiles }} {{.Name}}{{ end }}
// Package service provides gRPC/HTTP service registration
package service

import (
	"context"
	"fmt"
	"net/http"

	"github.com/auth0/go-jwt-middleware"
	"github.com/gorilla/mux"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/prometheus/client_golang/prometheus"
	log "github.com/sirupsen/logrus"
	"google.golang.org/grpc"

	{{ .GoProtoPkgAlias }} "{{ .GoPkg }}/{{ .GoProtoPkgAlias }}"
)

var (
	name       = "{{ lowerKebabCase .Name }}" // injected with -ldflags in Makefile
	version    = "latest" // injected with -ldflags in Makefile
	controller *{{ lowerPascalCase .ShortName }}HTTPController // HTTP/1.1 controller
)

func init() {
	controller = new{{ upperPascalCase .ShortName }}HTTPController()
}

// Service is the echo
type Service struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

// NewService return new {{ .Name }} service
func NewService() *Service {
	return &Service{
		Name:    name,
		Version: version,
	}
}

// RegisterGRPCServices register all grpc services
func (svc Service) RegisterGRPCServices(
	s *grpc.Server,
	jwtSecret string,
	caCert string,
	cert string,
	privKey string,
	// EXTRA : param
	{{ range .DbTypes }}{{ lowerPascalCase . }}DSN string,
	{{ end }}// END EXTRA : param
	// SUB-SERVICES DEFINITION : param-address
	// svc{{ "{{SubServiceNamePascalCase}}" }}Address string,
	{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address string,
	{{ end }}// END SUB-SERVICES DEFINITION : param-address
) {
	log.WithFields(log.Fields{
		"jwtSecret": jwtSecret,
		"caCert":    caCert,
		"cert":      cert,
		"privKey":   privKey,
		// EXTRA : log
		{{ range .DbTypes }}"{{ lowerPascalCase . }}DSN":  {{ lowerPascalCase . }}DSN,
		{{ end }}// END EXTRA : log
		// SUB-SERVICES DEFINITION : log-address
		// "svc{{ "{{SubServiceNamePascalCase}}" }}Address": svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}"svc{{ upperPascalCase .ShortName }}Address": svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : log-address
	}).Debug("RegisterGRPCServices")
	{{ .GoProtoPkgAlias }}.Register{{ upperPascalCase .ShortName }}Server(s, &{{ lowerPascalCase .ShortName }}Server{
		jwtSecret:     jwtSecret,
		caCertificate: caCert,
		certificate:   cert,
		privateKey:    privKey,
		// EXTRA : register server
		{{ range .DbTypes }}{{ lowerPascalCase . }}DataSourceName:  {{ lowerPascalCase . }}DSN,
		{{ end }}// END EXTRA : register server
		// SUB-SERVICES DEFINITION : register-address-to-server
		// svc{{ "{{SubServiceNamePascalCase}}" }}Address: svc{{ "{{SubServiceNamePascalCase}}" }}Address,
		{{ range .SubServices }}svc{{ upperPascalCase .ShortName }}Address: svc{{ upperPascalCase .ShortName }}Address,
		{{ end }}// END SUB-SERVICES DEFINITION : register-address-to-server
	})
}

// RegisterHTTPServices register all http services
func (svc Service) RegisterHTTPServices(ctx context.Context, mux *mux.Router, addr string, opts []grpc.DialOption, jwtMiddleware *jwtmiddleware.JWTMiddleware) {
	// get server mux
	gwmux := runtime.NewServeMux()
	err := {{ .GoProtoPkgAlias }}.Register{{ upperPascalCase .ShortName }}HandlerFromEndpoint(ctx, gwmux, addr, opts)
	if err != nil {
		log.Fatalf("RegisterGRPCGateway error : %s\n", err)
	}

	// prometheus instrument handler
	instrf := prometheus.InstrumentHandlerFunc

	// HTTP/1.1 routes
	// status handler
	mux.
		HandleFunc("/status", instrf("Http.Status", controller.Status))

	mux.
		HandleFunc("/version", instrf("Http.Version", controller.Version))

	mux.
		HandleFunc("/", instrf("Http.Root", func(w http.ResponseWriter, r *http.Request) {
			// The "/" pattern matches everything not matched by previous handlers
			fmt.Fprintf(w, "%s-%s OK", svc.Name, svc.Version)
		}))

	// swagger doc handler
	mux.
		PathPrefix("/api/v1/swagger.json").
		Handler(instrf("Api.Swagger", controller.Swagger))

	// to declare an authenticated handler do something like this
	// if jwtMiddleware == nil {
	//   mux.
	//     PathPrefix("/<URL>").
	//     Handler(instrf("<METRICS_KEY>", controller.<HTTP_HANDLER>))
	// } else {
	//   mux.
	//     PathPrefix("/<URL>").
	//     Handler(negroni.New(
	//       negroni.HandlerFunc(jwtMiddleware.HandlerWithNext),
	//       negroni.Wrap(instrf("<METRICS_KEY>", controller.<HTTP_HANDLER>)),
	//     ))
	// }

	// it's not necessary to use secure middleware for gRPC calls
	// api gateway handlers with metrics instrumentations
	routeMap := map[string]string{
{{- httpMetricsRouteMap .Name .ProtoFiles -}}
	}
	for route, label := range routeMap {
		mux.PathPrefix(route).Handler(instrf(label, gwmux.ServeHTTP))
	}

	// prometheus metrics handler
	mux.
		Handle("/metrics", prometheus.Handler())
}
